=== SECTION 5 & 6: OPERATIONAL MODEL & DESCRIPTORS ===

--- Page 2 ---

iii
Contents
1. Preface ........................................................................................................ vii
1.1 Intellectual Property Disclaimer ............................................................ vii
1.2 Contributors........................................................................................... vii
1.3 Scope of this Revision .......................................................................... viii
1.4 Revision History................................................................................... viii
1.5 Document Conventions .......................................................................... ix
2. Introduction .................................................................................................. 1
2.1 Scope ....................................................................................................... 1
2.2 Purpose .................................................................................................... 2
2.3 Related Documents ................................................................................. 3
3. Management Overview ................................................................................ 4
4. Functional Characteristics ............................................................................ 7
4.1 The HID Class ......................................................................................... 7
4.2 Subclass ................................................................................................... 8
4.3 Protocols. ................................................................................................. 9
4.4 Interfaces ............................................................................................... 10
4.5 Device Limitations ................................................................................ 11
5. Operational Model ...................................................................................... 12
5.1 Device Descriptor Structure .................................................................. 12
5.2 Report Descriptors ................................................................................ 14
5.3 Generic Item Format ............................................................................. 14
5.4 Item Parser ............................................................................................ 15
5.5 Usages ................................................................................................... 17
5.6 Reports .................................................................................................. 17
5.7 Strings ................................................................................................... 18
5.8 Format of Multibyte Numeric Values ................................................... 19
5.9 Orientation ............................................................................................ 20
5.10 Null Values........................................................................................ 20
6. Descriptors. ................................................................................................. 21
6.1 Standard Descriptors ............................................................................. 21
6.2 Class-Specific Descriptors .................................................................... 21
6.2.1 HID Descriptor .............................................................................. 22
6.2.2 Report Descriptor .......................................................................... 23
6.2.2.1 Items Types and Tags ............................................................ 26
6.2.2.2 Short Items ............................................................................ 26
6/27/01
--- Page 3 ---

iv Contents
6.2.2.3 Long items ............................................................................. 27
6.2.2.4 Main Items ............................................................................ 28
6.2.2.5 Input, Output, and Feature Items ........................................... 29
6.2.2.6 Collection, End Collection Items .......................................... 33
6.2.2.7 Global Items .......................................................................... 35
6.2.2.8 Local Items ............................................................................ 39
6.2.2.9 Padding .................................................................................. 42
6.2.3 Physical Descriptors ...................................................................... 43
7. Requests ..................................................................................................... 48
7.1 Standard Requests ................................................................................. 48
7.1.1 Get_Descriptor Request ................................................................ 49
7.1.2 Set_Descriptor Request ................................................................. 50
7.2 Class-Specific Requests ........................................................................ 50
7.2.1 Get_Report Request ...................................................................... 51
7.2.2 Set_Report Request ....................................................................... 52
7.2.3 Get_Idle Request ........................................................................... 52
7.2.4 Set_Idle Request ............................................................................ 52
7.2.5 Get_Protocol Request .................................................................... 54
7.2.6 Set_Protocol Request .................................................................... 54
8. Report Protocol........................................................................................... 55
8.1 Report Types ......................................................................................... 55
8.2 Report Format for Standard Items ......................................................... 55
8.3 Report Format for Array Items. ............................................................. 56
8.4 Report Constraints ................................................................................. 57
8.5 Report Example ..................................................................................... 57
Appendix A: Usage Tags ...................................................................................... 59
Appendix B: Boot Interface Descriptors .............................................................. 59
B.1 Protocol 1 (Keyboard) ............................................................................... 59
B.2 Protocol 2 (Mouse) .................................................................................... 61
Appendix C: Keyboard Implementation ............................................................... 62
Appendix D: Example Report Descriptors ........................................................... 64
D.1 Example Joystick Descriptor .................................................................... 64
Appendix E: Example USB Descriptors for HID Class Devices .......................... 66
E.1 Device Descriptor ...................................................................................... 66
E.2 Configuration Descriptor ........................................................................... 67
E.3 Interface Descriptor (Keyboard)................................................................ 67
E.4 HID Descriptor (Keyboard). ...................................................................... 68
E.5 Endpoint Descriptor (Keyboard) ............................................................... 68
E.6 Report Descriptor (Keyboard) ................................................................... 69
Contents v
E.7 Interface Descriptor (Mouse) .................................................................... 70
6/27/00:
--- Page 4 ---

E.8 HID Descriptor (Mouse) ........................................................................... 70
E.9 Endpoint Descriptor (Mouse) .................................................................... 70
E.10 Report Descriptor (Mouse) ...................................................................... 71
E.11 String Descriptors .................................................................................... 72
Appendix F: Legacy Keyboard Implementation ................................................... 73
F.1 Purpose ...................................................................................................... 73
F.2 Management Overview .............................................................................. 73
F.3 Boot Keyboard Requirements.................................................................... 74
F.4 Keyboard: Non-USB Aware System Design Requirements ...................... 75
F.5 Keyboard: Using the Keyboard Boot Protocol .......................................... 75
Appendix G: HID Request Support Requirements ............................................... 78
Appendix H: Glossary Definitions ........................................................................ 79
6/27/01
--- Page 5 ---


--- Page 6 ---

vii
1. Preface
1.1 Intellectual Property Disclaimer
THIS SPECIFICATION IS PROVIDED “AS IS” WITH NO WARRANTIES WHATSOEVER
INCLUDING ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTY OTHERWISE ARISING OUT OF ANY PROPOSAL,
SPECIFICATION, OR SAMPLE.
TO THE MAXIMUM EXTENT OF USB IMPLEMENTERS FORUM’S RIGHTS, USB
IMPLEMENTERS FORUM HEREBY GRANTS A LICENSE UNDER COPYRIGHT TO REPRODUCE
THIS SPECIFICATION FOR INTERNAL USE ONLY (E.G., ONLY WITHIN THE COMPANY OR
ORGANIZATION THAT PROPERLY DOWNLOADED OR OTHERWISE OBTAINED THE
SPECIFICATION FROM USB IMPLEMENTERS FORUM, OR FOR AN INDIVIDUAL, ONLY FOR
USE BY THAT INDIVIDUAL). THIS SPECIFICATION MAY NOT BE REPUBLISHED
EXTERNALLY OR OTHERWISE TO THE PUBLIC.
IT IS CONTEMPLATED THAT MANY IMPLEMENTATIONS OF THIS SPECIFICATION (E.G., IN A
PRODUCT) DO NOT REQUIRE A LICENSE TO USE THIS SPECIFICATION UNDER COPYRIGHT.
FOR CLARITY, HOWEVER, TO THE MAXIMUM EXTENT OF USB IMPLEMENTERS FORUM’S
RIGHTS, USB IMPLEMENTERS FORUM HEREBY GRANTS A LICENSE UNDER COPYRIGHT TO
USE THIS SPECIFICATION AS REASONABLY NECESSARY TO IMPLEMENT THIS
SPECIFICATION (E.G., IN A PRODUCT).
NO OTHER LICENSE, EXPRESS OR IMPLIED, BY ESTOPPEL OR OTHERWISE, TO ANY PATENT
OR OTHER INTELLECTUAL PROPERTY RIGHTS IS GRANTED OR INTENDED HEREBY.
USB IMPLEMENTERS FORUM AND THE AUTHORS OF THIS SPECIFICATION DISCLAIM ALL
LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF PROPRIETARY RIGHTS,
RELATING TO IMPLEMENTATION OF INFORMATION IN THIS SPECIFICATION. AUTHORS OF
THIS SPECIFICATION ALSO DO NOT WARRANT OR REPRESENT THAT SUCH
IMPLEMENTATION(S) WILL NOT INFRINGE SUCH RIGHTS.
All product names are trademarks, registered trademarks, or service marks of their respective owners.
1.2 Contributors
While many people contributed to this document, only one contributor is listed
from each organization.
Company Contact
Alps Mike Bergman
Cybernet Tom Peurach
DEC Tom Schmidt
Intel Steve McGowan
Key Tronic Corporation Jodi Crowe
LCS/Telegraphics Robert Dezmelyk
Logitech Remy Zimmermann
Microsoft Corporation Mike Van Flandern
NCR Bob Nathan
Sun Microsystems Mike Davis
ThrustMaster Joe Rayhawk
6/27/01
--- Page 7 ---

viii Device Class Definition for Human Interface Devices (HID) Version 1.11
1.3 Scope of this Revision
This version 1.11 release incorporates all review requests approved at it’s release
date that apply to the USB Device Class Definition for Human Interface Devices
(HID Specification).
1.4 Revision History
Version Release date Description
1.11 6/27/01 1.11 Release.
Incorporated HID review requests: 39, 53, 60, 61, and
62.
1.1 4/7/99 1.1 Release.
Incorporated HID review requests: 18, 19, 20, 21, 22,
23, 25, 26, 28, 29, 30, 32, 35 and 52.
Removed Usage Table sections. These can be found in
the Universal Serial Bus HID Usage Tables document.
1.0 1/30/96 1.0 Release.
6/27/00:
--- Page 8 ---

Preface ix
1.5 Document Conventions
This specification uses the following typographic conventions
Example of convention Description
Get_Report, Report Words in bold with initial letter capitalized
indicate elements with special meaning
such as requests, descriptors, descriptor
sets, classes, or subclasses.
Data, Non-Data Proper-cased words are used to distinguish
types or categories of things. For example
Data and Non-Data type Main items.
BValue Italicized letters or words indicate
placeholders for information supplied by
the developer.
bValue, bcdName, wOther Placeholder prefixes such as ‘b’, ‘bcd’, and
‘w’ are used to denote placeholder type. For
example:
b bits or bytes; dependent on context
bcd binary-coded decimal
bm bitmap
d descriptor
i index
w word
[bValue] Items inside square brackets are optional.
... Ellipses in syntax, code, or samples indicate
‘and so on...’ where additional optional
items may be included (defined by the
developer).
{this (0) | that (1)} Braces and a vertical bar indicate a choice
between two or more items or associated
values.
Collection This font is used for code, pseudo-code, and
End Collection samples.
6/277/00:
--- Page 9 ---


--- Page 10 ---

1
2. Introduction
Universal Serial Bus (USB) is a communications architecture that gives a personal
computer (PC) the ability to interconnect a variety of devices using a simple four-
wire cable. The USB is actually a two-wire serial communication link that runs at
either 1.5 or 12 megabits per second (mbs). USB protocols can configure devices
at startup or when they are plugged in at run time. These devices are broken into
various device classes. Each device class defines the common behavior and
protocols for devices that serve similar functions. Some examples of USB device
classes are shown in the following table:
Device Class Example Device
Display Monitor
Communication Modem
Audio Speakers
Mass storage Hard drive
Human interface Data glove
See Also
For more information on terms and terminology, see Appendix H: Glossary
Definitions. The rest of this document assumes you have read and
understood the terminology defined in the glossary.
2.1 Scope
This document describes the Human Interface Device (HID) class for use with
Universal Serial Bus (USB). Concepts from the USB Specification are used but
not explained in this document.
See Also
The USB Specification is recommended pre-reading for understanding the
content of this document. See Section 2.3: Related Documents.
The HID class consists primarily of devices that are used by humans to control
the operation of computer systems. Typical examples of HID class devices
include:
Keyboards and pointing devices—for example, standard mouse devices,

trackballs, and joysticks.
Front-panel controls—for example: knobs, switches, buttons, and sliders.

Controls that might be found on devices such as telephones, VCR remote

controls, games or simulation devices—for example: data gloves, throttles,
steering wheels, and rudder pedals.
6/27/01
--- Page 11 ---

10 Device Class Definition for Human Interface Devices (HID) Version 1.11
Devices that may not require human interaction but provide data in a similar

format to HID class devices—for example, bar-code readers, thermometers, or
voltmeters.
Many typical HID class devices include indicators, specialized displays, audio
feedback, and force or tactile feedback. Therefore, the HID class definition
includes support for various types of output directed to the end user.
Note Force feedback devices requiring real time interaction are covered in a
separate document titled “USB Physical Interface Device (PID) Class.”
See Also
For more conceptual information, see the USB Specification, Chapter 9,
“USB Device Framework..” See Section 2.3: Related Documents.
2.2 Purpose
This document is intended to supplement the USB Specification and provide HID
manufacturers with the information necessary to build USB-compatible devices. It
also specifies how the HID class driver should extract data from USB devices.
The primary and underlying goals of the HID class definition are to:
Be as compact as possible to save device data space.

Allow the software application to skip unknown information.

Be extensible and robust.

Support nesting and collections.

Be self-describing to allow generic software applications.

6/27/00:
--- Page 12 ---

Introduction 3
2.3 Related Documents
This document references the following related documents:
Name Comment
Universal Serial Bus (USB) Specification, In particular, see Chapter 9, “USB Device
Version 1.0 Framework.”
USB Class Specification for Legacy
Software
USB HID Usage Supplement A detailed extension of the usages listed in
Appendix A.
USB Physical Interface Device (PID)
Specification
USB Audio Device Class
The most current information is maintained at the following site on the World
Wide Web: http://www.usb.org
6/277/00:
--- Page 13 ---

4 Device Class Definition for Human Interface Devices (HID) Version 1.11
3. Management Overview
Information about a USB device is stored in segments of its ROM (read-only
memory). These segments are called descriptors. An interface descriptor can
identify a device as belonging to one of a finite number of classes. The HID class
is the primary focus of this document.
A USB/HID class device uses a corresponding HID class driver to retrieve and
route all data.
The routing and retrieval of data is accomplished by examining the descriptors of
the device and the data it provides.
The HID class device descriptor identifies which other HID class descriptors are
present and indicates their sizes. For example, Report and Physical Descriptors.
A Report descriptor describes each piece of data that the device generates and
what the data is actually measuring.
For example, a Report descriptor defines items that describe a position or button
state. Item information is used to:
Determine where to route input—for example, send input to mouse or joystick

API.
Allow software to assign functionality to input—for example, use joystick

input to position a tank.
6/27/00:
--- Page 14 ---

Management Overview 5
By examining an items (collectively called the Report descriptor) the HID class
driver is able to determine the size and composition of data reports from the HID
class device.
Physical descriptor sets are optional descriptors which provide information about
the part or parts of the human body used to activate the controls on a device.
6/277/00:
--- Page 15 ---

6 Device Class Definition for Human Interface Devices (HID) Version 1.11
All of these things can be combined to illustrate the descriptor structure.
The rest of this specification documents the implementation details, caveats, and
restrictions for developing HID class devices and drivers.
6/27/00:
--- Page 16 ---

Functional Characteristics 7
4. Functional Characteristics
This section describes the functional characteristics of the HID:
Class

Subclass

Interfaces

4.1 The HID Class
USB devices are segmented into device classes that:
Have similar data transport requirements.

Share a single class driver.

For example, Audio class devices require isochronous data pipes. HID class
devices have different (and much simpler) transport requirements. The transport
requirements for HID class devices are identified in this document.
Note USB devices with data requirements outside the range of defined classes
must provide their own class specifications and drivers as defined by the USB
Specification. See Section 2.3: Related Documents.
A USB device may be a single class type or it may be composed of multiple
classes. For example, a telephone hand set might use features of the HID, Audio,
and Telephony classes. This is possible because the class is specified in the
Interface descriptor and not the Device descriptor. This is discussed further in
Section 5.1: Device Descriptor Structure.
The USB Core Specification defines the HID class code. The bInterfaceClass
member of an Interface descriptor is always 3 for HID class devices.
See Also
The Audio Class Specification defines audio device transport requirements
in greater detail. See Section 2.3: Related Documents.
6/277/00:
--- Page 17 ---

8 Device Class Definition for Human Interface Devices (HID) Version 1.11
4.2 Subclass
During the early development of the HID specification, subclasses were intended
to be used to identify the specific protocols of different types of HID class
devices. While this mirrors the model currently in use by the industry (all devices
use protocols defined by similar popular devices), it quickly became apparent that
this approach was too restrictive. That is, devices would need to fit into narrowly
defined subclasses and would not be able to provide any functionality beyond that
supported by the subclass.
The HID committee agreed on the improbability that subclass protocols for all
possible (and yet to be conceived) devices could be defined. In addition, many
known devices seemed to straddle multiple classifications—for example,
keyboards with locators, or locators that provided keystrokes. Consequently, the
HID class does not use subclasses to define most protocols. Instead, a HID class
device identifies its data protocol and the type of data provided within its Report
descriptor.
The Report descriptor is loaded and parsed by the HID class driver as soon as the
device is detected. Protocols for existing and new devices are created by mixing
data types within the Report descriptor.
Note Because the parser for the Report descriptor represents a significant
amount of code, a simpler method is needed to identify the device protocol for
devices requiring BIOS support (Boot Devices). HID class devices use the
Subclass part to indicate devices that support a predefined protocol for either
mouse devices or keyboards (that is, the device can be used as a Boot Device).
The boot protocol can be extended to include additional data not recognized by
the BIOS, or the device may support a second preferred protocol for use by the
HID class driver.
The bInterfaceSubClass member declares whether a device supports a boot
interface, otherwise it is 0.
Subclass Codes
Subclass Code Description
0 No Subclass
1 Boot Interface Subclass
2 - 255 Reserved
See Also
Boot Report descriptors are listed in Appendix B: Boot Interface
Descriptors. For HID subclass and protocol codes, see Appendix E:
Example USB Descriptors for HID Class Devices.
6/27/00:
--- Page 18 ---

Functional Characteristics 9
4.3 Protocols
A variety of protocols are supported HID devices. The bInterfaceProtocol
member of an Interface descriptor only has meaning if the bInterfaceSubClass
member declares that the device supports a boot interface, otherwise it is 0.
Protocol Codes
Protocol Code Description
0 None
1 Keyboard
2 Mouse
3 - 255 Reserved
6/277/00:
--- Page 19 ---

10 Device Class Definition for Human Interface Devices (HID) Version 1.11
4.4 Interfaces
A HID class device communicates with the HID class driver using either the
Control (default) pipe or an Interrupt pipe.
The Control pipe is used for:
Receiving and responding to requests for USB control and class data.

Transmitting data when polled by the HID class driver (using the Get_Report

request).
Receiving data from the host.

The Interrupt pipe are used for:
Receiving asynchronous (unrequested) data from the device.

Transmitting low latency data to the device.

The Interrupt Out pipe is optional. If a device declares an Interrupt Out endpoint
then Output reports are transmitted by the host to the device through the Interrupt
Out endpoint. If no Interrupt Out endpoint is declared then Output reports are
transmitted to a device through the Control endpoint, using Set_Report(Output)
requests.
Note Endpoint 0 is a Control pipe always present in USB devices. Therefore,
only the Interrupt In pipe is described for the Interface descriptor using an
Endpoint descriptor. In fact, several Interface descriptors may share Endpoint 0.
An Interrupt Out pipe is optional and requires an additional Endpoint descriptor
if declared.
Pipe Description Required
Control (Endpoint 0) USB control, class request codes, and Y
polled data (Message data).
Interrupt In Data in, that is, data from device (Stream Y
data).
Interrupt Out Data out, that is, data to the device (Stream N
data).
See Also
For details about the Control pipe, see the USB Specification. See Section
2.3: Related Documents.
6/27/00:
--- Page 20 ---

Functional Characteristics 11
4.5 Device Limitations
This specification applies to both high-speed and low-speed HID class devices.
Each type of device possesses various limitations, as defined in Chapter 5 of the
Universal Serial Bus Specification.
6/277/00:
--- Page 21 ---

12 Device Class Definition for Human Interface Devices (HID) Version 1.11
5. Operational Model
This section outlines the basic operational model of a HID class device.
Flowchart elements represent tables of information with the firmware.
5.1 Device Descriptor Structure
At the topmost level, a descriptor includes two tables of information referred to as
the Device descriptor and the String descriptor. A standard USB Device
descriptor specifies the Product ID and other information about the device. For
example, Device descriptor fields primarily include:
Class

Subclass

Vendor

Product

Version

For HID class devices, the:
Class type is not defined at the Device descriptor level. The class type for a

HID class device is defined by the Interface descriptor.
6/27/00:
--- Page 22 ---

Operational Model 13
Subclass field is used to identify Boot Devices.

Note The bDeviceClass and bDeviceSubClass fields in the Device Descriptor
should not be used to identify a device as belonging to the HID class. Instead use
the bInterfaceClass and bInterfaceSubClass fields in the Interface descriptor.
See Also
The HID class driver identifies the exact type of device and features by
examining additional class-specific descriptors. For more information, see
Section 6.2: Class-Specific Descriptors. For methods of descriptor retrieval,
see Section 7: Requests
6/277/00:
--- Page 23 ---

14 Device Class Definition for Human Interface Devices (HID) Version 1.11
5.2 Report Descriptors
Preceding descriptors are illustrated by flowchart items that represent tables of
information. Each table of information can be thought of as a block of data.
Instead of a block of data, Report descriptors are composed of pieces of
information. Each piece of information is called an Item.
5.3 Generic Item Format
An item is piece of information about the device. All items have a one-byte prefix
that contains the item tag, item type, and item size.
An item may include optional item data. The size of the data portion of an item is
determined by its fundamental type. There are two basic types of items: short
items and long items. If the item is a short item, its optional data size may be 0, 1,
2, or 4 bytes. If the item is a long item, its bSize value is always 2. The following
example illustrates possible values within the 1-byte prefix for a long item.
6/27/00:
--- Page 24 ---

Operational Model 15
5.4 Item Parser
The HID class driver contains a parser used to analyze items found in the Report
descriptor. The parser extracts information from the descriptor in a linear fashion.
The parser collects the state of each known item as it walks through the
descriptor, and stores them in an item state table. The item state table contains the
state of individual items.
From the parser’s point of view, a HID class device looks like the following
figure:
6/277/00:
--- Page 25 ---

16 Device Class Definition for Human Interface Devices (HID) Version 1.11
When some items are encountered, the contents of the item state table are moved.
These items include all Main, Push, and Pop items.
When a Main item is found, a new report structure is allocated and initialized

with the current item state table. All Local items are then removed from the
item state table, but Global items remain. In this way, Global items set the
default value for subsequent new Main items. A device with several similar
controls—for example, six axes—would need to define the Global items only
once prior to the first Main item.
Note Main items are associated with a collection by the order in which they
are declared. A new collection starts when the parser reaches a Collection
item. The item parser associates with a collection all Main items defined
between the Collection item and the next End Collection item.
When a Push item is encountered, the item state table is copied and placed on

a stack for later retrieval.
When a Pop item is found, the item state table is replaced with the top table

from the stack. For example:
Unit (Meter), Unit Exponent (-3), Push, Unit Exponent (0)
When the parser reaches a Push item, it places the items defining units of
millimeters (10-3 meters) on the stack. The next item changes the item state
table to units of meters (100 meters).
The parser is required to parse through the whole Report descriptor to find all
Main items. This is necessary in order to analyze reports sent by the device.
See Also
For details, see Section 8: Report Protocol.
6/27/00:
--- Page 26 ---

Operational Model 17
5.5 Usages
Usages are part of the Report descriptor and supply an application developer with
information about what a control is actually measuring. In addition, a Usage tag
indicates the vendor’s suggested use for a specific control or group of controls.
While Report descriptors describe the format of the data—for example, three 8-
bit fields—a Usage tag defines what should be done with the data—for example,
x, y, and z input. This feature allows a vendor to ensure that the user sees
consistent function assignments to controls across applications.
A Report descriptor can have multiple Usage tags. There is a one-to-one
correspondence between usages and controls, one usage control defined in the
descriptor. An array indicates that each field of a Report descriptor represents
several physical controls. Each control may have attributes such as a usage
assigned to it. For example, an array of four buttons could have a unique Usage
tag for each button.
A Usage is interpreted as a 32 bit unsigned value where the high order 16 bits
defines the Usage Page and the low order 16 bits defines a Usage ID. Usage IDs
are used to select individual Usage on a Usage Page.
See Also
For an example, see Appendix E. 10: Report Descriptor (Mouse).
5.6 Reports
Using USB terminology, a device may send or receive a transaction every USB
frame (1 millisecond). A transaction may be made up of multiple packets (token,
data, handshake) but is limited in size to 8 bytes for low-speed devices and 64
bytes for high-speed devices. A transfer is one or more transactions creating a set
of data that is meaningful to the device—for example, Input, Output, and
Feature reports. In this document, a transfer is synonymous with a report.
Most devices generate reports, or transfers, by returning a structure in which each
data field is sequentially represented. However, some devices may have multiple
report structures on a single endpoint, each representing only a few data fields.
For example, a keyboard with an integrated pointing device could independently
report “key press” data and “pointing” data over the same endpoint. Report ID
items are used to indicate which data fields are represented in each report
structure. A Report ID item tag assigns a 1-byte identification prefix to each
6/277/00:
--- Page 27 ---

18 Device Class Definition for Human Interface Devices (HID) Version 1.11
report transfer. If no Report ID item tags are present in the Report descriptor, it
can be assumed that only one Input, Output, and Feature report structure exists
and together they represent all of the device’s data.
Note Only Input reports are sent via the Interrupt In pipe. Feature and
Output reports must be initiated by the host via the Control pipe or an optional
Interrupt Out pipe.
If a device has multiple report structures, all data transfers start with a 1-byte
identifier prefix that indicates which report structure applies to the transfer. This
allows the class driver to distinguish incoming pointer data from keyboard data by
examining the transfer prefix.
5.7 Strings
A collection or data field can have a particular label (string index) associated with
it. Strings are optional.
The Usage tag of an item is not necessarily the same as a string associated with
the Main item. However, strings may be useful when a vendor-defined usage is
required. The String descriptor contains a list of text strings for the device.
See Also
For details, see Appendix E: Example USB Descriptors for HID Class
Devices.
6/27/00:
--- Page 28 ---

Operational Model 19
5.8 Format of Multibyte Numeric Values
Multibyte numeric values in reports are represented in little-endian format, with
the least significant byte at the lowest address. The Logical Minimum and Logical
Maximum values identify the range of values that will be found in a report. If
Logical Minimum and Logical Maximum are both positive values then a sign bit
is unnecessary in the report field and the contents of a field can be assumed to be
an unsigned value. Otherwise, all integer values are signed values represented in
2’s complement format. Floating point values are not allowed.
The least significant bit in a value is stored in bit 0, the next more significant in
bit 1 and so on up to the size of the value. The following example illustrates bit
Byte 3 Byte 2 Byte 1 Byte 0
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
Default Value 0 (MSb) (LSb) (MSb) (LSb) (MSb) (LSb)
Y Axis: 12 - Bits X Axis: 12 - Bits Report ID
Button 1
Button 2
Button 3
representation of a long integer value.
Byte Bits
0 0-7
1 8-15
2 16-23
3 24-31
6/277/00:
--- Page 29 ---

20 Device Class Definition for Human Interface Devices (HID) Version 1.11
5.9 Orientation
HID class devices are encouraged, where possible, to use a right-handed
coordinate system. If a user is facing a device, report values should increase as
controls are moved from left to right (X), from far to near (Y) and from high to
low (Z).
Controls reporting binary data should use the convention 0 = off, or False, and 1 =
on, or True. Examples of such controls are keys, buttons, power switches, and
device proximity sensors.
5.10 Null Values
HID class devices support the ability to ignore selected fields in a report at run-
time. This is accomplished by declaring bit field in a report that is capable of
containing a range of values larger than those actually generated by the control. If
the host or the device receives an out-of-range value then the current value for the
respective control will not be modified.
A hardware developer must carefully evaluate the controls in an individual report
to determine how an application on the host will use them. If there are any
situations in which an application will not modify a particular field every time the
report is sent to the device, then the field should provide a Null value. With Null
values, the host can initialize all fields in a report that it does not wish to modify
to their null (out-of-range) value and set the fields that it wishes to modify to valid
(in-range) values.
If an 8-bit field is declared and the range of valid values is 0 to 0x7F then any
value between 0x80 and 0xFF will be considered out of range and ignored when
received. The initialization of null values in a report is much easier if they are all
the same.
NOTE: It is highly recommended that 0 be included in the set of Null values so
that report buffers can simply be set to zero to establish the “don’t care” state for
all fields.
6/27/00:
--- Page 30 ---

Descriptors 21
6. Descriptors
6.1 Standard Descriptors
The HID class device class uses the following standard USB descriptors:
Device

Configuration

Interface

Endpoint

String

See Also
For details about these descriptors as defined for a HID class device, see
Appendix E: Example USB Descriptors for HID Class Devices. For
general information about standard USB descriptors, see Chapter 9 of the
USB Specification, “USB Device Framework.”
6.2 Class-Specific Descriptors
Each device class includes one or more class-specific descriptors. These
descriptors differ from standard USB descriptors. A HID class device uses the
following class-specific descriptors:
HID

Report

Physical

6/277/00:
--- Page 31 ---

22 Device Class Definition for Human Interface Devices (HID) Version 1.11
6.2.1 HID Descriptor
Description The HID descriptor identifies the length and type of subordinate descriptors for a
device.
Parts Part Offset/Size Description
(Bytes)
bLength 0/1 Numeric expression that is the total size of the
HID descriptor.
bDescriptorType 1/1 Constant name specifying type of HID
descriptor.
bcdHID 2/2 Numeric expression identifying the HID Class
Specification release.
bCountryCode 4/1 Numeric expression identifying country code of
the localized hardware.
bNumDescriptors 5/1 Numeric expression specifying the number of
class descriptors (always at least one i.e. Report
descriptor.)
bDescriptorType 6/1 Constant name identifying type of class
descriptor. See Section 7.1.2: Set_Descriptor
Request for a table of class descriptor constants.
wDescriptorLength 7/2 Numeric expression that is the total size of the
Report descriptor.
[bDescriptorType]... 9/1 Constant name specifying type of optional
descriptor.
[wDescriptorLength]... 10/2 Numeric expression that is the total size of the
optional descriptor.
Remarks If an optional descriptor is specified, a corresponding length entry must also be

specified.
Multiple optional descriptors and associated lengths may be specified up to

offset (3*n)+6 and (3*n)+7 respectively.
The value bNumDescriptors identifies the number of additional class specific

descriptors present. This number must be at least one (1) as a Report
descriptor will always be present. The remainder of the HID descriptor has the
length and type of each additional class descriptor.
The value bCountryCode identifies which country the hardware is localized

for. Most hardware is not localized and thus this value would be zero (0).
However, keyboards may use the field to indicate the language of the key caps.
Devices are not required to place a value other than zero in this field, but some
operating environments may require this information. The following table
specifies the valid country codes.
6/27/00:
--- Page 32 ---

Descriptors 23
Code (decimal) Country Code (decimal) Country
00 Not Supported 18 Netherlands/Dutch
01 Arabic 19 Norwegian
02 Belgian 20 Persian (Farsi)
03 Canadian-Bilingual 21 Poland
04 Canadian-French 22 Portuguese
05 Czech Republic 23 Russia
06 Danish 24 Slovakia
07 Finnish 25 Spanish
08 French 26 Swedish
09 German 27 Swiss/French
10 Greek 28 Swiss/German
11 Hebrew 29 Switzerland
12 Hungary 30 Taiwan
13 International (ISO) 31 Turkish-Q
14 Italian 32 UK
15 Japan (Katakana) 33 US
16 Korean 34 Yugoslavia
17 Latin American 35 Turkish-F
36-255 Reserved
6.2.2 Report Descriptor
The Report descriptor is unlike other descriptors in that it is not simply a table of
values. The length and content of a Report descriptor vary depending on the
number of data fields required for the device’s report or reports. The Report
descriptor is made up of items that provide information about the device. The first
part of an item contains three fields: item type, item tag, and item size. Together
these fields identify the kind of information the item provides.
There are three item types: Main, Global, and Local. There are five Main item
tags currently defined:
Input item tag: Refers to the data from one or more similar controls on a

device. For example, variable data such as reading the position of a single axis
or a group of levers or array data such as one or more push buttons or
switches.
Output item tag: Refers to the data to one or more similar controls on a device

such as setting the position of a single axis or a group of levers (variable data).
Or, it can represent data to one or more LEDs (array data).
Feature item tag: Describes device input and output not intended for

consumption by the end user —for example, a software feature or Control
Panel toggle.
6/277/00:
--- Page 33 ---

24 Device Class Definition for Human Interface Devices (HID) Version 1.11
Collection item tag: A meaningful grouping of Input, Output, and Feature

items—for example, mouse, keyboard, joystick, and pointer.
End Collection item tag: A terminating item used to specify the end of a

collection of items.
The Report descriptor provides a description of the data provided by each control
in a device. Each Main item tag (Input, Output, or Feature) identifies the size of
the data returned by a particular control, and identifies whether the data is
absolute or relative, and other pertinent information. Preceding Local and Global
items define the minimum and maximum data values, and so forth. A Report
descriptor is the complete set of all items for a device. By looking at a Report
descriptor alone, an application knows how to handle incoming data, as well as
what the data could be used for.
One or more fields of data from controls are defined by a Main item and further
described by the preceding Global and Local items. Local items only describe the
data fields defined by the next Main item. Global items become the default
attributes for all subsequent data fields in that descriptor. For example, consider
the following (details omitted for brevity):
Report Size (3)
Report Count (2)
Input
Report Size (8)
Input
Output
The item parser interprets the Report descriptor items above and creates the
following reports (the LSB is on the left):
6/27/00:
--- Page 34 ---

Descriptors 25
A Report descriptor may contain several Main items. A Report descriptor must
include each of the following items to describe a control’s data (all other items are
optional):
Input (Output or Feature)

Usage

Usage Page

Logical Minimum

Logical Maximum

Report Size

Report Count

The following is a coding sample of items being used to define a 3-button mouse.
In this case, Main items are preceded by Global items like Usage, Report Count
or Report Size (each line is a new item).
Usage Page (Generic Desktop), ;Use the Generic Desktop Usage Page
Usage (Mouse),
Collection (Application), ;Start Mouse collection
Usage (Pointer),
Collection (Physical), ;Start Pointer collection
Usage Page (Buttons)
Usage Minimum (1),
Usage Maximum (3),
Logical Minimum (0),
Logical Maximum (1), ;Fields return values from 0 to 1
Report Count (3),
Report Size (1), ;Create three 1 bit fields (button 1, 2, & 3)
Input (Data, Variable, Absolute), ;Add fields to the input report.
Report Count (1),
Report Size (5), ;Create 5 bit constant field
Input (Constant), ;Add field to the input report
Usage Page (Generic Desktop),
Usage (X),
Usage (Y),
Logical Minimum (-127),
Logical Maximum (127), ;Fields return values from -127 to 127
Report Size (8),
Report Count (2), ;Create two 8 bit fields (X & Y position)
Input (Data, Variable, Relative), ;Add fields to the input report
End Collection, ;Close Pointer collection
End Collection ;Close Mouse collection
6/277/00:
--- Page 35 ---

26 Device Class Definition for Human Interface Devices (HID) Version 1.11
6.2.2.1 Items Types and Tags
All items contain a 1-byte prefix which denotes the basic type of the item. The
HID class defines two basic formats for items:
Short items: 1 – 5 bytes total length; used for the most commonly occurring

items. A short item typically contains 1 or 0 bytes of optional data.
Long items: 3 – 258 bytes in length; used for items that require larger data

structures for parts.
Note This specification defines only items that use the short format.
The two item formats should not be confused with types of items such as Main,
Global, and Local.
See Also
For overview information, see Section 5.3: Generic Item Format.
6.2.2.2 Short Items
Description The short item format packs the item size, type, and tag into the first byte. The
first byte may be followed by 0, 1, 2, or 4 optional data bytes depending on the
size of the data.
Parts
Part Description
bSize Numeric expression specifying size of data:
0 = 0 bytes
1 = 1 byte
2 = 2 bytes
3 = 4 bytes
bType Numeric expression identifying type of item where:
0 = Main
1 = Global
2 = Local
3 = Reserved
bTag Numeric expression specifying the function of the item.
[data] Optional data.
Remarks  A short item tag doesn’t have an explicit value for bSize associated with it.
Instead, the value of the item data part determines the size of the item. That is,
if the item data can be represented in one byte, then the data part can be
specified as 1 byte, although this is not required.
6/27/00:
--- Page 36 ---

Descriptors 27
If a large data item is expected, it can still be abbreviated if all of its high-order

bits are zero. For example, a 32-bit part in which bytes 1, 2, and 3 are all 0 can
be abbreviated as a single byte.
There are three categories of short item tags: Main, Global, and Local. The

item type (bType) specifies the tag category and consequently the item’s
behavior.
6.2.2.3 Long items
Description Like the short item format, the long item format packs the item size, type, and tag
into the first byte. The long item format uses a special item tag value to indicate
that it is a long item. The long item size and long item tag are each 8-bit
quantities. The item data may contain up to 255 bytes of data.
Parts
Part Description
bSize Numeric expression specifying total size of item where size is 10 (2
bytes); denotes item type as long.
bType Numeric expression identifying type of item where
3 = Reserved
bTag Numeric expression specifying the function of the item; always 1111.
[bDataSize] Size of long item data.
[bLongItemTag] Long item tag.
[data] Optional data items.
Important No long item tags are defined in this document. These tags are
reserved for future use. Tags xF0–xFF are vendor defined.
6/277/00:
--- Page 37 ---

28 Device Class Definition for Human Interface Devices (HID) Version 1.11
6.2.2.4 Main Items
Description Main items are used to either define or group certain types of data fields within a
Report descriptor. There are two types of Main items: data and non-data. Data-
type Main items are used to create a field within a report and include Input,
Output, and Feature. Other items do not create fields and are subsequently
referred to as non-data Main items.
Parts One-Byte
Prefix (nn
represents
Main item tag size value) Valid Data
Input 1000 00 nn Bit 0 {Data (0) | Constant (1)}
Bit 1 {Array (0) | Variable (1)}
Bit 2 {Absolute (0) | Relative (1)}
Bit 3 {No Wrap (0) | Wrap (1)}
Bit 4 {Linear (0) | Non Linear (1)}
Bit 5 {Preferred State (0) | No Preferred (1)}
Bit 6 {No Null position (0) | Null state(1)}
Bit 7 Reserved (0)
Bit 8 {Bit Field (0) | Buffered Bytes (1)}
Bit 31-9 Reserved (0)
Output 1001 00 nn Bit 0 {Data (0) | Constant (1)}
Bit 1 {Array (0) | Variable (1)}
Bit 2 {Absolute (0) | Relative (1)}
Bit 3 {No Wrap (0) | Wrap (1)}
Bit 4 {Linear (0) | Non Linear (1)}
Bit 5 {Preferred State (0) | No Preferred (1)}
Bit 6 {No Null position (0) | Null state(1)}
Bit 7 {Non Volatile (0) | Volatile (1)}
Bit 8 {Bit Field (0) | Buffered Bytes (1)}
Bit 31-9 Reserved (0)
Feature 1011 00 nn Bit 0 {Data (0) | Constant (1)}
Bit 1 {Array (0) | Variable (1)}
Bit 2 {Absolute (0) | Relative (1)}
Bit 3 {No Wrap (0) | Wrap (1)}
Bit 4 {Linear (0) | Non Linear (1)}
Bit 5 {Preferred State (0) | No Preferred (1)}
Bit 6 {No Null position (0) | Null state(1)}
Bit 7 {Non Volatile (0) | Volatile (1)}
Bit 8 {Bit Field (0) | Buffered Bytes (1)}
Bit 31-9 Reserved (0)
Collection 1010 00 nn 0x00 Physical (group of axes)
0x01 Application (mouse, keyboard)
0x02 Logical (interrelated data)
0x03 Report
0x04 Named Array
0x05 Usage Switch
0x06 Usage Modifier
0x07-0x7F Reserved
0x80-0xFF Vendor-defined
End Collection 1100 00 nn Not applicable. Closes an item collection.
6/27/00:
--- Page 38 ---

Descriptors 29
One-Byte
Prefix (nn
represents
Main item tag size value) Valid Data
Reserved 1101 00 nn to Not applicable. Reserved for future items.
1111 00 nn
Remarks The default data value for all Main items is zero (0).

An Input item could have a data size of zero (0) bytes. In this case the value of

each data bit for the item can be assumed to be zero. This is functionally
identical to using a item tag that specifies a 4-byte data item followed by four
zero bytes.
6.2.2.5 Input, Output, and Feature Items
Description Input, Output, and Feature items are used to create data fields within a report.
An Input item describes information about the data provided by one or more

physical controls. An application can use this information to interpret the data
provided by the device. All data fields defined in a single item share an
identical data format.
The Output item is used to define an output data field in a report. This item is

similar to an Input item except it describes data sent to the device—for
example, LED states.
Feature items describe device configuration information that can be sent to

the device.
6/277/00:
--- Page 39 ---

30 Device Class Definition for Human Interface Devices (HID) Version 1.11
Parts Bit Part Value Description
0 Data | 0 | 1 Indicates whether the item is data or a constant
Constant value. Data indicates the item is defining report
fields that contain modifiable device data. Constant
indicates the item is a static read-only field in a
report and cannot be modified (written) by the
host.
1 Array | 0 | 1 Indicates whether the item creates variable or array
Variable data fields in reports. In variable fields, each field
represents data from a physical control. The
number of bits reserved for each field is
determined by preceding Report Size/Report Count
items. For example, a bank of eight on/off switches
could be reported in 1 byte declared by a variable
Input item where each bit represents one switch, on
(1) or off (0) (Report Size = 1, Report Count = 8).
Alternatively, a variable Input item could add 1
report byte used to represent the state of four three-
position buttons, where the state of each button is
represented by two bits (Report Size = 2, Report
Count = 4). Or 1 byte from a variable Input item
could represent the x position of a joystick (Report
Size = 8, Report Count = 1).
An array provides an alternate means for
describing the data returned from a group of
buttons. Arrays are more efficient, if less flexible
than variable items. Rather than returning a single
bit for each button in the group, an array returns an
index in each field that corresponds to the pressed
button (like keyboard scan codes). An out-of range
value in and array field is considered no controls
asserted. Buttons or keys in an array that are
simultaneously pressed need to be reported in
multiple fields. Therefore, the number of fields in
an array input item (Report Count) dictates the
maximum number of simultaneous controls that
can be reported. A keyboard could report up to
three simultaneous keys using an array with three
8-bit fields (Report Size = 8, Report Count = 3).
Logical Minimum specifies the lowest index value
returned by the array and Logical Maximum
specifies the largest. The number of elements in the
array can be deduced by examining the difference
between Logical Minimum and Logical Maximum
(number of elements = Logical Maximum -
Logical Minimum + 1).
2 Absolute | 0 | 1 Indicates whether the data is absolute (based on a
Relative fixed origin) or relative (indicating the change in
value from the last report). Mouse devices usually
provide relative data, while tablets usually provide
absolute data.
6/27/00:
--- Page 40 ---

Descriptors 31
Bit Part Value Description
3 No Wrap | 0 | 1 Indicates whether the data “rolls over” when
Wrap reaching either the extreme high or low value. For
example, a dial that can spin freely 360 degrees
might output values from 0 to 10. If Wrap is
indicated, the next value reported after passing the
10 position in the increasing direction would be 0.
4 Linear | 0 | 1 Indicates whether the raw data from the device has
Nonlinear been processed in some way, and no longer
represents a linear relationship between what is
measured and the data that is reported.
Acceleration curves and joystick dead zones are
examples of this kind of data. Sensitivity settings
would affect the Units item, but the data would still
be linear.
5 Preferred 0 | 1 Indicates whether the control has a preferred state
State | No to which it will return when the user is not
Preferred physically interacting with the control. Push
buttons (as opposed to toggle buttons) and self-
centering joysticks are examples.
6 No Null 0 | 1 Indicates whether the control has a state in which it
Position | is not sending meaningful data. One possible use of
Null State the null state is for controls that require the user to
physically interact with the control in order for it to
report useful data. For example, some joysticks
have a multidirectional switch (a hat switch).
When a hat switch is not being pressed it is in a
null state. When in a null state, the control will
report a value outside of the specified Logical
Minimum and Logical Maximum (the most
negative value, such as -128 for an 8-bit value).
7 Non- 0 | 1 Indicates whether the Feature or Output control's
volatile | value should be changed by the host or not.
Volatile Volatile output can change with or without host
interaction. To avoid synchronization problems,
volatile controls should be relative whenever
possible. If volatile output is absolute, when
issuing a Set Report (Output), request set the value
of any control you don't want to change to a value
outside of the specified Logical Minimum and
Logical Maximum (the most negative value, such
as -128 for an 8-bit value). Invalid output to a
control is ignored by the device.
Reserved 0 Data bit 7 is undefined for input items and is
reserved for future use.
8 Bit Field | 0 | 1 Indicates that the control emits a fixed-size stream
Buffered of bytes. The contents of the data field are
Bytes determined by the application. The contents of the
buffer are not interpreted as a single numeric
quantity. Report data defined by a Buffered Bytes
item must be aligned on an 8-bit boundary. The
data from a bar code reader is an example.
6/277/00:
--- Page 41 ---

32 Device Class Definition for Human Interface Devices (HID) Version 1.11
Bit Part Value Description
9 - 31 Reserved 0 Reserved for future use.
Remarks If the Input item is an array, only the Data/Constant, Variable/Array and

Absolute/Relative attributes apply.
The number of data fields in an item can be determined by examining the

Report Size and Report Count values. For example an item with a Report
Size of 8 bits and a Report Count of 3 has three 8-bit data fields.
The value returned by an Array item is an index so it is recommended that:

1) An Array field returns a 0 value when no controls in the array are asserted.
2) The Logical Minimum equals 1.
3) The Logical Maximum equal the number of elements in the array.
Input items define input reports accessible via the Control pipe with a

Get_Report (Input) request.
Input type reports are also sent at the polling rate via the Interrupt In pipe.

The Data | Constant, Variable | Array, Absolute | Relative, Nonlinear,

Wrap, and Null State data for an Output item are identical to those data for
an Input item.
Output items make Output reports accessible via the Control pipe with a

Set_Report (Output) command.
Output type reports can optionally be sent via an Interrupt Out pipe.

While similar in function, Output and Feature items differ in the following
ways:
Feature items define configuration options for the device and are usually

set by a control panel application. Because they affect the behavior of a
device (for example, button repeat rate, reset origin, and so forth), Feature
items are not usually visible to software applications. Conversely, Output
items represent device output to the user (for example, LEDs, audio, tactile
feedback, and so forth). Software applications are likely to set device
Output items.
Feature items may be attributes of other items. For example, an Origin

Reset Feature may apply to one or more position Input items. Like Output
items, Feature items make up Feature Reports accessible via the Control
pipe with the Get_Report (Feature) and Set_Report (Feature) requests.
6/27/00:

=== APPENDIX B: BOOT INTERFACE ===

--- Page 49 ---

40 Device Class Definition for Human Interface Devices (HID) Version 1.11
Parts One-Byte
Prefix (nn
represents
Tag size value) Description
Usage 0000 10 nn Usage index for an item usage; represents a
suggested usage for the item or collection. In the
case where an item represents multiple controls, a
Usage tag may suggest a usage for every variable
or element in an array.
Usage Minimum 0001 10 nn Defines the starting usage associated with an array
or bitmap.
Usage Maximum 0010 10 nn Defines the ending usage associated with an array
or bitmap.
Designator Index 0011 10 nn Determines the body part used for a control. Index
points to a designator in the Physical descriptor.
Designator 0100 10 nn Defines the index of the starting designator
Minimum associated with an array or bitmap.
Designator 0101 10 nn Defines the index of the ending designator
Maximum associated with an array or bitmap.
String Index 0111 10 nn String index for a String descriptor; allows a string
to be associated with a particular item or control.
String Minimum 1000 10 nn Specifies the first string index when assigning a
group of sequential strings to controls in an array
or bitmap.
String Maximum 1001 10 nn Specifies the last string index when assigning a
group of sequential strings to controls in an array
or bitmap.
Delimiter 1010 10 nn Defines the beginning or end of a set of local items
(1 = open set, 0 = close set).
Reserved 1010 10 nn to Reserved.
1111 10 nn
Remarks While Local items do not carry over to the next Main item, they may apply to

more than one control within a single item. For example, if an Input item
defining five controls is preceded by three Usage tags, the three usages would
be assigned sequentially to the first three controls, and the third usage would
also be assigned to the fourth and fifth controls. If an item has no controls
(Report Count = 0), the Local item tags apply to the Main item (usually a
collection item).
To assign unique usages to every control in a single Main item, simply specify

each Usage tag sequentially (or use Usage Minimum or Usage Maximum).
All Local items are unsigned integers.

Note It is important that Usage be used properly. While very specific usages
exist (landing gear, bicycle wheel, and so on) those usages are intended to
identify devices that have very specific applications. A joystick with generic
buttons should never assign an application-specific usage to any button.
Instead, it should assign a generic usage such as “Button.” However, an
6/27/00:
--- Page 50 ---

Descriptors 41
exercise bicycle or the cockpit of a flight simulator may want to narrowly
define the function of each of its data sources.
It is also important to remember that Usage items convey information about

the intended use for the data and may not correspond to what is actually being
measured. For example, a joystick would have an X and Y Usage associated
with its axis data (and not Usages Rx and Ry.)
See Also
For a list of Usage parts, see Appendix A: Usage Tags.
Because button bitmaps and arrays can represent multiple buttons or switches

with a single item, it may be useful to assign multiple usages to a Main item.
Usage Minimum specifies the usage to be associated with the first
unassociated control in the array or bitmap. Usage Maximum specifies the
end of the range of usage values to be associated with item elements. The
following example illustrates how this could be used for a 105-key keyboard.
Tag Result
Report Count (1) One field will be added to the report.
Report size (8) The size of the newly added field is 1
byte (8 bits).
Logical Minimum (0) Defines 0 as the lowest possible return
value.
Logical Maximum (101) Defines 101 as the highest possible return
value and sets the range from 0 to 101.
Usage Page (0x07) Selects keyboard usage page.
Usage Minimum (0x00) Assigns first of 101-key usages.
Usage Maximum (0x65) Assigns last of 101-key usages.
Input: (Data, Array, Absolute) Creates and adds a 1-byte array to the
input report.
If a Usage Minimum is declared as and extended usage then the associated

Usage Maximum must also be declared as an extended usage.
Interpretation of Usage, Usage Minimum or Usage Maximum items vary as a

function of the item’s bSize field. If the bSize field = 3 then the item is
interpreted as a 32 bit unsigned value where the high order 16 bits defines the
Usage Page and the low order 16 bits defines the Usage ID. 32 bit usage items
that define both the Usage Page and Usage ID are often referred to as
“Extended” Usages.
If the bSize field = 1 or 2 then the Usage is interpreted as an unsigned value
that selects a Usage ID on the currently defined Usage Page. When the parser
encounters a main item it concatenates the last declared Usage Page with a
Usage to form a complete usage value. Extended usages can be used to
override the currently defined Usage Page for individual usages.

6/277/00:
--- Page 51 ---

42 Device Class Definition for Human Interface Devices (HID) Version 1.11
Two or more alternative usages may be associated with a control by simply

bracketing them with Delimiter items. Delimiters allow aliases to be defined
for a control so that an application can access it in more than one way. The
usages that form a delimited set are organized in order of preference, where
the first usage declared is the most preferred usage for the control.
HID parsers must handle Delimiters however, the support for the alternative
usages that they define is optional. Usages other than the first (most
preferred) usage defined may not be made accessible by system software.
Delimiters cannot be used when defining usages that apply to Application

Collections or Array items.
6.2.2.9 Padding
Reports can be padded to byte-align fields by declaring the appropriately sized
main item and not declaring a usage for the main item.
6/27/00:
--- Page 52 ---

Descriptors 43
6.2.3 Physical Descriptors
A Physical Descriptor is a data structure that provides information about the
specific part or parts of the human body that are activating a control or controls.
For example, a physical descriptor might indicate that the right hand thumb is
used to activate button 5. An application can use this information to assign
functionality to the controls of a device.
Note Physical Descriptors are entirely optional. They add complexity and offer
very little in return for most devices. However, some devices, particularly those
with a large number of identical controls (for example, buttons) will find that
Physical Descriptors help different applications assign functionality to these
controls in a more consistent manner. Skip the following section if you do not
plan on supporting Physical Descriptors.
Similar Physical Descriptors are grouped into sets. Designator Index items
contained in the Report descriptor map items (or controls) to a specific Physical
descriptor contained in a Physical Descriptor set (hereafter referred to
generically as a descriptor set).
Each descriptor set consists of a short header followed by one or more Physical
Descriptors. The header defines the Bias (whether the descriptor set is targeted at
a right or left-handed user) and the Preference of the set. For a particular Bias, a
vendor can define alternate Physical Descriptors (for example, a right-handed
user may be able to hold a device in more than one way, therefore remapping the
fingers that touch the individual items).
Each Physical Descriptor consists of the following three fields:
Designator: identifies the actual body part that effects an item—for example,

the hand.
Qualifier: further defines the designator—for example, right or left hand.

Effort: value quantifying the effort the user must employ to effect the item.

If multiple items identify the same Designator/Qualifier combination, the Effort
value can be used to resolve the assignment of functions. An Effort value of 0
would be used to define the button a finger rests on when the hand is in the “at
rest” position, that is, virtually no effort is required by the user to activate the
button. Effort values increment as the finger has to stretch to reach a control.
The only time two or more controls will have identical
Designator/Qualifier/Effort combinations is because they are physically
connected together. A long skinny key cap with ‘+’ at one end and ‘-’ at the other
is a good example of this. If it is implemented electrically as two discrete push-
buttons, it is possible to have both pressed at the same time even though they are
both under the same key cap. If the vendor decided that for this product, pressing
the ‘+’ and ‘-’ buttons simultaneously was valid then they would be described as
two discrete push-buttons with identical Physical Descriptors. However, if the
key cap was labeled “Volume” and pressing both buttons at the same time had no
meaning, then a vendor would probably choose to describe the buttons as a single
6/277/00:
--- Page 53 ---

44 Device Class Definition for Human Interface Devices (HID) Version 1.11
item with three valid states: off, more volume (+), and less volume (-). In this case
only one Physical Descriptor would be needed.
Consider a joystick that has two buttons (A and B) on the left side of the base and
a trigger button on the front of the stick that is logically ORed with Button A. The
joystick base is most often held in the left hand while the stick is manipulated
with the right. So, the first descriptor set would designate Button A as:
Index Finger, Right, Effort 0
Similarly, button B would be designated as:
Thumb, Left, Effort 0
If the joystick was placed on a table top and the left hand was used to control both
buttons on the base then another descriptor set could identify an alternate mapping
for Button A of:
Middle Finger, Left, Effort 0
Button B would be designated as:
Index Finger, Left, Effort 0
Important Designator tags are optional and may be provided for all, some, or
none of a device’s items or elements.
Descriptor set 0 is a special descriptor set that specifies the number of additional
descriptor sets, and also the number of Physical Descriptors in each set.
Part Offset/Size (Bytes) Description
bNumber 0/1 Numeric expression specifying the number of
Physical Descriptor sets. Do not include Physical
Descriptor 0 itself in this number.
bLength 1/2 Numeric expression identifying the length of each
Physical descriptor.
Upon receiving a Get_Descriptor request from the host, a HID class device will
return the descriptor set specified in the request wValue low byte. A descriptor set
consists of a header followed by one or more Physical Descriptors.
6/27/00: